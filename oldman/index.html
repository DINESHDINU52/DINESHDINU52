<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OBJ Model Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: transparent;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border: none;
      padding: 0;
      margin: 0;
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffffff;
      font-family: Arial, sans-serif;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      z-index: 1000;
    }
  </style>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading model...</div>
  
  <script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = null; // Transparent background
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    camera.position.z = 10;
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true 
    });
    renderer.setClearColor(0x000000, 0); // Fully transparent
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Controls setup
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 3;
    controls.maxDistance = 30;
    
    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 10, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 50;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);
    
    // Additional point light for better illumination
    const pointLight = new THREE.PointLight(0xffffff, 0.5);
    pointLight.position.set(-10, 5, -10);
    scene.add(pointLight);

    // Initialize loaders
    const objLoader = new OBJLoader();
    const loadingDiv = document.getElementById('loading');
    let modelObject = null;
    let autoRotate = true;
    
    // Helper function to apply material to model
    function applyMaterialToObject(object, material) {
      object.traverse((child) => {
        if (child.isMesh) {
          child.material = material;
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
    }
    
    // Improved texture loading function
    function loadTextures() {
      const textureLoader = new THREE.TextureLoader();
      
      return new Promise((resolve) => {
        const textures = {};
        const textureFiles = [
          { file: 'texture_diffuse.png', key: 'map' },
          { file: 'texture_normal.png', key: 'normalMap' },
          { file: 'texture_roughness.png', key: 'roughnessMap' },
          { file: 'texture_metallic.png', key: 'metalnessMap' },
          { file: 'texture_ao.png', key: 'aoMap' }, // Ambient occlusion
          // { file: 'texture_pbr.png', key: 'map' }, // Uncomment if using PBR instead of diffuse
        ];
        
        let completed = 0;
        const total = textureFiles.length;
        
        if (total === 0) {
          resolve(textures);
          return;
        }
        
        textureFiles.forEach(({ file, key }) => {
          textureLoader.load(
            file,
            (texture) => {
              // Configure texture settings
              texture.encoding = THREE.sRGBEncoding;
              
              if (key === 'normalMap') {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
              }
              
              textures[key] = texture;
              completed++;
              
              // Update loading message
              loadingDiv.textContent = `Loading textures... ${Math.round(completed / total * 100)}%`;
              
              if (completed === total) {
                resolve(textures);
              }
            },
            undefined,
            (error) => {
              console.warn(`Failed to load texture: ${file}`, error);
              completed++;
              if (completed === total) {
                resolve(textures);
              }
            }
          );
        });
      });
    }
    
    // Helper function to center and scale the model
    function addModelToScene(object, textures) {
      if (!object || !object.children || object.children.length === 0) {
        loadingDiv.textContent = 'Error: Invalid model';
        loadingDiv.style.color = '#ff6666';
        return;
      }
      
      // Create material with loaded textures
      const materialConfig = {
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.4,
        side: THREE.DoubleSide,
      };
      
      // Add loaded textures to material
      Object.keys(textures).forEach(key => {
        if (textures[key]) {
          materialConfig[key] = textures[key];
        }
      });
      
      const material = new THREE.MeshStandardMaterial(materialConfig);
      applyMaterialToObject(object, material);
      
      // Center the model
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center);
      
      // Scale the model to fit the view
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0) {
        const scale = 7 / maxDim; // Adjust this value to make model bigger/smaller
        object.scale.set(scale, scale, scale);
      }
      
      // Store reference to the model
      modelObject = object;
      scene.add(object);
      
      // Hide loading message
      loadingDiv.style.display = 'none';
      
      // Adjust camera to fit model
      const distance = maxDim * 2;
      camera.position.set(0, distance * 0.5, distance);
      camera.lookAt(0, 0, 0);
      controls.update();
    }
    
    // Load textures first, then the model
    loadingDiv.textContent = 'Loading textures...';
    
    loadTextures().then((textures) => {
      loadingDiv.textContent = 'Loading model...';
      
      objLoader.load(
        'base.obj',
        (object) => {
          addModelToScene(object, textures);
        },
        (xhr) => {
          if (xhr.lengthComputable) {
            const percentComplete = xhr.loaded / xhr.total * 100;
            loadingDiv.textContent = `Loading model... ${Math.round(percentComplete)}%`;
          }
        },
        (error) => {
          console.error('Error loading OBJ model:', error);
          loadingDiv.textContent = 'Error loading model. Please check the console.';
          loadingDiv.style.color = '#ff6666';
        }
      );
    }).catch((error) => {
      console.error('Error in texture loading:', error);
      loadingDiv.textContent = 'Error loading textures';
      loadingDiv.style.color = '#ff6666';
    });
    
    // Stop auto-rotation when user interacts
    controls.addEventListener('start', () => {
      autoRotate = false;
    });
    
    // Optional: Resume auto-rotation after inactivity
    let inactivityTimer;
    controls.addEventListener('end', () => {
      clearTimeout(inactivityTimer);
      inactivityTimer = setTimeout(() => {
        autoRotate = true;
      }, 3000); // Resume after 3 seconds of inactivity
    });
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Auto-rotate the model if enabled
      if (modelObject && autoRotate) {
        modelObject.rotation.y += 0.01; // Rotation speed
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Clean up resources on page unload
    window.addEventListener('beforeunload', () => {
      if (modelObject) {
        modelObject.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            // Dispose textures
            if (child.material.map) child.material.map.dispose();
            if (child.material.normalMap) child.material.normalMap.dispose();
            if (child.material.roughnessMap) child.material.roughnessMap.dispose();
            if (child.material.metalnessMap) child.material.metalnessMap.dispose();
            if (child.material.aoMap) child.material.aoMap.dispose();
            child.material.dispose();
          }
        });
      }
      renderer.dispose();
      controls.dispose();
    });
    
    // Optional: Add keyboard controls
    window.addEventListener('keydown', (event) => {
      switch(event.key) {
        case ' ': // Spacebar toggles rotation
          autoRotate = !autoRotate;
          break;
        case 'r': // R key resets camera
          camera.position.set(0, 5, 10);
          controls.reset();
          break;
      }
    });
  </script>
</body>
</html>
